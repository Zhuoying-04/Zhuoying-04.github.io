<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhuoying-04.github","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java基础概念java的特点是什么？ 平台无关性：java程序一次编写，处处运行，主要就是通过JVM实现的，java编译器将java程序编译为字节码.class文件，该字节码文件可以在任何安装了JVM的系统上运行。   字节码文件的结构  魔数：每个 .class 文件开头都有一个魔数 0xCAFEBABE，这是一个固定的标识符，用来标识这个文件是一个有效的 .class 文件。 版本信息：">
<meta property="og:type" content="article">
<meta property="og:title" content="java学习">
<meta property="og:url" content="http://zhuoying-04.github/2025/04/05/java%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="April&#39;s Blog">
<meta property="og:description" content="Java基础概念java的特点是什么？ 平台无关性：java程序一次编写，处处运行，主要就是通过JVM实现的，java编译器将java程序编译为字节码.class文件，该字节码文件可以在任何安装了JVM的系统上运行。   字节码文件的结构  魔数：每个 .class 文件开头都有一个魔数 0xCAFEBABE，这是一个固定的标识符，用来标识这个文件是一个有效的 .class 文件。 版本信息：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-05T08:46:19.000Z">
<meta property="article:modified_time" content="2025-04-08T02:10:56.467Z">
<meta property="article:author" content="April">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhuoying-04.github/2025/04/05/java%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java学习 | April's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">April's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">2</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zhuoying-04.github/2025/04/05/java%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/rose.jpg">
      <meta itemprop="name" content="April">
      <meta itemprop="description" content="Do not go gentle into that good night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="April's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-05 16:46:19" itemprop="dateCreated datePublished" datetime="2025-04-05T16:46:19+08:00">2025-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-08 10:10:56" itemprop="dateModified" datetime="2025-04-08T10:10:56+08:00">2025-04-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="java的特点是什么？"><a href="#java的特点是什么？" class="headerlink" title="java的特点是什么？"></a>java的特点是什么？</h3><ul>
<li><p>平台无关性：java程序一次编写，处处运行，主要就是通过JVM实现的，java编译器将java程序编译为字节码.class文件，该字节码文件可以在任何安装了JVM的系统上运行。</p>
<p>  字节码文件的结构</p>
<ol>
<li><strong>魔数</strong>：每个 <code>.class</code> 文件开头都有一个魔数 <code>0xCAFEBABE</code>，这是一个固定的标识符，用来标识这个文件是一个有效的 <code>.class</code> 文件。</li>
<li><strong>版本信息</strong>：紧接着魔数后面是 Java 字节码的版本信息，指定该字节码文件的兼容 Java 版本。</li>
<li><strong>常量池</strong>：常量池包含了类、字段、方法、字符串等信息的引用。它是字节码文件中非常重要的一部分，JVM 在执行过程中会通过常量池来访问这些常量。</li>
<li><strong>类信息</strong>：包括类的访问标志、类的名字、继承关系、实现的接口等信息。</li>
<li><strong>字段和方法信息</strong>：包含类的字段（变量）和方法的签名，字段的类型、访问修饰符、方法的名称和参数等。</li>
<li><strong>字节码指令</strong>：类的实际执行代码。每个方法都会包含一组字节码指令，这些指令是由 JVM 解释并执行的。</li>
</ol>
</li>
<li><p>面向对象：java认为万物皆是对象，面向对象特性使得代码易于维护和重用，包括类，对象，继承，多态，抽象和封装。</p>
</li>
<li><p>内存管理：java有自己的内存回收机制（JVM垃圾回收章节）</p>
</li>
</ul>
<h3 id="java的优势劣势"><a href="#java的优势劣势" class="headerlink" title="java的优势劣势"></a>java的优势劣势</h3><p>​	<strong>java的优势：</strong>跨平台+面向对象+自动垃圾回收+多线程支持+安全模型</p>
<p>​	<strong>java的劣势：</strong>性能差，内存消耗严重，因为JVM本身就占内存，语法繁琐，面向对象过于严格</p>
<h3 id="java为什么是跨平台的"><a href="#java为什么是跨平台的" class="headerlink" title="java为什么是跨平台的"></a>java为什么是跨平台的</h3><p>java支持跨平台，主要依赖于JVM关系比较大。JVM是一个用C++&#x2F;C编写的软件，它可以将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同的平台上安装对应版本的虚拟机，就可以运行字节码文件，运行我们编写的java程序。</p>
<p>而这个过程中，java编写的程序没有做任何改变，仅仅是通过JVM这一中间件，就可以运行字节码文件，运行我们编译好的java程序。</p>
<h3 id="JVM、JDK、JRE的关系"><a href="#JVM、JDK、JRE的关系" class="headerlink" title="JVM、JDK、JRE的关系"></a>JVM、JDK、JRE的关系</h3><ol>
<li>JVM是虚拟机，是java程序运行的环境，它负责将java字节码解释或者编译为机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得java程序具备跨平台性</li>
<li>JRE是java运行时所需最小的环境，它包含JVM和一组java类库，用于支持java程序的执行。JRE不包括开发工具。</li>
<li>JDK是java开发工具包，是开发java程序所需工具集合，它包含JVM，编译器，调试器等开发工具。同时还包括一系列类库。JDK提供了开发，编译，调试和运行java程序所需的全部工具和环境。</li>
</ol>
<h3 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h3><ol>
<li>编译型语言：在程序执行前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接执行编译后的代码，速度快，但是跨平台性较差。如C,C++。</li>
<li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并且执行代码，跨平台性比较好，但执行速度相对较慢。如python，javascript。</li>
</ol>
<h3 id="为什么java解释和编译都有"><a href="#为什么java解释和编译都有" class="headerlink" title="为什么java解释和编译都有"></a>为什么java解释和编译都有</h3><p>编译型：java源代码首先会被整体编译为字节码文件。并且JVM中每一个方法都有一个计数器，调用一次该方法计数器就会加1，当累计计数大于一定的值，证明该方法是一个热点方法，就会使用JIT进行编译将热点码生成机器码文件。而对于普通方法就是使用解释器进行解释执行。所以java既是编译型语言也是解释型语言。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="八种基本的数据类型"><a href="#八种基本的数据类型" class="headerlink" title="八种基本的数据类型"></a>八种基本的数据类型</h3><ul>
<li>数值型：整数类型（int，long，short，byte）和浮点数类型（float，double）</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用字节数</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128-127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-32768-32767</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2147483648-2147483648</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">-2^63 -2^63-1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">1.4E-45-3.4028235E38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">4.9E-324-1.7976931348623157E308</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">0-65535</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
<td align="center">true&#x2F;false</td>
</tr>
</tbody></table>
<p>E+数字表示E之前的数字要乘以10的多少倍</p>
<p><strong>注意：</strong></p>
<ol>
<li>浮点数默认是double，如果要声明一个常量为float，要在末尾加上f&#x2F;F</li>
<li>整数类型默认为int，声明long要在末尾加上l&#x2F;L，</li>
<li>char类型是无符号的，所以从0开始</li>
<li>char的包装类为Character，int的包装类为Integer，其他的包装类为首字母大写。</li>
</ol>
<h3 id="数据类型转换方式："><a href="#数据类型转换方式：" class="headerlink" title="数据类型转换方式："></a>数据类型转换方式：</h3><ul>
<li>自动类型转换：当目标类型的范围大于原类型时，java会自动将原类型转化为目标类型，如int转long，float转double</li>
<li>强制类型转换：目标类型 变量名 &#x3D; （目标类型）原类型值，当目标类型的范围小于原类型时，需要使用强制类型转换，如long转int，double转int等。</li>
<li>字符串转化：java提供了将字符串表示的数据转化为其他类型数据的方式，如Integer.parseInt()可以将字符串转为整形，Double.parseDouble()可以将字符串转化为浮点型数据。</li>
<li>数值之间的转换：java提供了数值类型之间的转换方式，如将整形转化为字符型，将字符型转化为整形等。如Character.forDigit()会将数字1转为字符“1”，而不是根据1的ASCII值来转化。Integer。parseInt（）可以将数字字符串转为对应的数字，如果输入的不是数字字符串而是“abc”这种，就会报错。并且要注意一定参数是字符串而不能是字符类型。</li>
</ul>
<h3 id="类型互转后会出现什么问题"><a href="#类型互转后会出现什么问题" class="headerlink" title="类型互转后会出现什么问题"></a>类型互转后会出现什么问题</h3><ul>
<li>数据丢失：当将一个范围较大的数据类型转换为范围较小的数据类型时会发生数据丢失。比如long转int时，如果long值超出了int可以表示的范围，转换结果是截断后的低位部分，高位部分数据就会丢失。</li>
<li>精度损失：在浮点数类型转化中，可能会发生精度损失。由于浮点数的表示不同，将double转为float时，精度可能会损失</li>
<li>类型不匹配导致错误：在进行类型转化时要注意确保原类型和目标类型是兼容的，否则就会导致错误。比如boolean不能转化为其他类型。</li>
</ul>
<h3 id="为什么要使用bigDecimal不用double"><a href="#为什么要使用bigDecimal不用double" class="headerlink" title="为什么要使用bigDecimal不用double"></a>为什么要使用bigDecimal不用double</h3><p>double执行的是二进制运算，而二进制小数不能准确地表示所有十进制小数，比如0.1我们就不能用一个二进制小数表示。</p>
<p>比如0.05和0.01这两个的二进制表示都是一个无限循环小数，当你计算0.05+0.01时，计算机会存储为近似值，并且因为这些数值的表示不完全精确，最终结果就会偏离0.06.</p>
<p>所以我们在牵涉到金钱的计算时都需要使用Decimal。并且创建BigDecimal时都要使用字符串作为参数。</p>
<h3 id="装箱和拆箱是什么意思"><a href="#装箱和拆箱是什么意思" class="headerlink" title="装箱和拆箱是什么意思"></a>装箱和拆箱是什么意思</h3><p>装箱指的是将基本数据类型转化为对应的包装类，装箱发生在两个情况：</p>
<ul>
<li><p>赋值时：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10;//装箱</span><br><span class="line">int n = i;//拆箱</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法调用时：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer show(Integer i)</span><br><span class="line">&#123;</span><br><span class="line">	Syttem.out.println(i);</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line">show(3);//装箱，3是int类型，而show的参数是Integer类型，所以调用show(3)时会将int值转为对应的Integer</span><br><span class="line">int result = show(3);//拆箱，返回值为Integer，将Integer赋值给int类型的变量就会发生拆箱</span><br></pre></td></tr></table></figure></li>
</ul>
<p>自动装箱的弊端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = 0;</span><br><span class="line">for(int i = 0;i&lt;5000;i++)</span><br><span class="line">&#123;</span><br><span class="line">	sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该循环中，sum+&#x3D;i等同于sum &#x3D; sum +i，但是+这个操作符不适用于Integer对象，所以sum进行自动拆箱操作，进行数值相加，再自动装箱转化为Integer对象。它的内部变化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = 0;</span><br><span class="line">for(int i = 0;i&lt;5000;i++)</span><br><span class="line">&#123;</span><br><span class="line">	int result = sum.valueOf() + i;</span><br><span class="line">	sum = new Integer(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在该循环当中，会创建将近4000个无用的Integer对象，在这样庞大的循环当中，会降低程序性能并加重垃圾回收的工作量。因此在编程时要注意到这一点，正确的声明变量类型。</p>
<h3 id="java中为什么要有包装类"><a href="#java中为什么要有包装类" class="headerlink" title="java中为什么要有包装类"></a>java中为什么要有包装类</h3><p>对象封装有很多好处，可以把属性和处理这些数据的方法结合在一起。并且java中绝大部分方法和类都是用来处理类类型对象的。比如ArrayList集合类只能以类作为他的存储对象，如果想把int数据存入list是不可能的，只能把它包装成类才能被List接受。所以包装类的存在非常有必要。</p>
<ul>
<li>泛型中的应用：在java当中，泛型只能使用引用类型而不能使用基本类型。假设我们有一个列表想将其排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用Collections.sort()方法。但是我们使用Integer包装类，就可以轻松使用Collection.sort方法。</li>
<li>转换中的应用：在javaz中基本数据类型和引用数据类型不能直接进行转换，必须使用包装类来实现。比如int转化为string，需要先将int转化为Integer，再转化为String。</li>
<li>集合中的应用：java集合中只能存储对象，不能存储基本数据类型</li>
</ul>
<h3 id="Integer和int的区别"><a href="#Integer和int的区别" class="headerlink" title="Integer和int的区别"></a>Integer和int的区别</h3><ul>
<li>基本数据类型和引用类型：int是基本数据类型，string是引用类型。基本数据类型是java中的最基本的数据类型，他是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。如果一个基本数据类型单独作为局部变量定义，他的内存分配在栈内存中。当方法执行结束以后，局部变量的内存就会释放。如果一个基本数据类型作为类的 成员变量（即对象的属性）存在，它存储在 堆内存 中的对象内部，作为该对象的一部分。这些基本数据类型值与对象的生命周期一致，只有当对象被销毁时，基本数据类型的内存才会被回收。</li>
<li>空指针异常：int变量可以默认赋值为0，作为局部变量时必须进行显式初始化。而作为成员变量时会自动赋予默认值。而Integer变量必须实例化对象来赋值，如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值。</li>
</ul>
<h3 id="Integer有这么多优势为什么还要保存int"><a href="#Integer有这么多优势为什么还要保存int" class="headerlink" title="Integer有这么多优势为什么还要保存int"></a>Integer有这么多优势为什么还要保存int</h3><p>当你在方法中定义了一个局部引用类型变量时，如果你要去访问p.name，那么实际上p的引用存在栈内存中，先去栈中拿到引用，再根据引用去堆内存中拿到具体数据。而如果是定义了一个属性是引用类型的，那么这个属性是存放在父对象的堆中内存结构当中。而对于基本数据类型，变量对应的内存块直接存储数据本身。所以基本数据类型的读写效率要比包装类高效。此外在64位JVM上，在开启压缩引用的情况下，一个Integer对象要占据16个字节内存空间，而int只占用4字节。</p>
<h3 id="Integer的缓存池"><a href="#Integer的缓存池" class="headerlink" title="Integer的缓存池"></a>Integer的缓存池</h3><p>java的Integer内部实现了一个静态缓存池。在Integer类的静态内部类IntegerCache中有一个静态代码块，他会在第一次访问Integer.valueOf()或者其他相关方法时执行。在 <code>IntegerCache</code> 静态代码块中，创建了一个 <code>Integer</code> 数组，存储着 <code>-128</code> 到 <code>127</code> 之间的所有 <code>Integer</code> 对象。Integer对象会被创建并存入 <code>cache</code> 数组，之后每次使用这些值时，<code>Integer.valueOf()</code> 会直接从缓存池中返回对应的对象，而不会再创建新的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a = 127;  // 触发缓存池的初始化</span><br><span class="line">        Integer b = 127;  // 使用已经缓存的对象</span><br><span class="line">        System.out.println(a == b);  // 输出 true，因为缓存池中已经有了相同的对象</span><br><span class="line"></span><br><span class="line">        Integer x = 128;  // 不在缓存池范围内</span><br><span class="line">        Integer y = 128;  // 不在缓存池范围内</span><br><span class="line">        System.out.println(x == y);  // 输出 false，因为大于 127 的值不会缓存</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a和b实际上指的是一个对象。那么对a进行修改不会影响b嘛？</p>
<ul>
<li><p><code>Integer</code> 是不可变类（immutable），值一旦创建就不能改变（所有的包装类都是不可变类）；</p>
</li>
<li><p>所有对 <code>Integer</code> 值的“修改”都是创建了一个新对象；</p>
</li>
<li><p>缓存池中的 <code>Integer</code> 实例永远不会被改动，只会被共享使用；</p>
</li>
</ul>
<p>所以即使多个变量引用同一个缓存池对象，也不会互相影响。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="怎么理解面向对象"><a href="#怎么理解面向对象" class="headerlink" title="怎么理解面向对象"></a>怎么理解面向对象</h3><p>面向对象是一种编程范式，它将现实世界中的事物抽象为对象。面向对象编程的设计思想是对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。</p>
<ul>
<li>封装：将对象的属性和行为结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立</li>
<li>继承：继承是一种可以使得子类自动共享父类数据结构和方法的机制。他是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。</li>
<li>多态：多态是指允许不同类的对象对同一消息做出响应。即同一个接口，使用不同的实例而执行不同的操作。多态可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。</li>
</ul>
<h3 id="多态体现在那些方向"><a href="#多态体现在那些方向" class="headerlink" title="多态体现在那些方向"></a>多态体现在那些方向</h3><ul>
<li><p>方法重载：同一个类中有多个同名方法，他们具有不同的参数列表（参数类型，顺序，数量不同）。虽然方法名字相同，但是根据传入的参数不同，编译器会在编译时确定正确的方法。</p>
</li>
<li><p>方法重写：指的是子类能够提供对于父类中同名方法的具体实现。在运行时JVM会根据对象的实际类型决定调用哪个版本的方法。</p>
</li>
<li><p>接口与实现：多个类可以实现同一个接口，并且用接口类型的引用来调用这些方法，这使得程序在面对不同具体实现时保持一贯的调用方法。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface Animal &#123;</span><br><span class="line">    void makeSound();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog implements Animal &#123;</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;Woof!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat implements Animal &#123;</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;Meow!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal a1 = new Dog();  // Animal引用指向Dog对象</span><br><span class="line">        Animal a2 = new Cat();  // Animal引用指向Cat对象</span><br><span class="line"></span><br><span class="line">        a1.makeSound();  // 输出：Woof!</span><br><span class="line">        a2.makeSound();  // 输出：Meow!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  根据引用具体指向的是dog还是cat来动态调用makeSound方法</p>
</li>
<li><p>向上转型和向下转型：父类引用指向子类对象，这是向上转型，通过这种办法可以在运行时采用不同的子类实现。向下转型是将父类引用转回其子类类型</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal a = new Dog();       // 向上转型</span><br><span class="line">        Dog d = (Dog) a;            // 向下转型</span><br><span class="line">        d.makeSound();             // Dog barks</span><br><span class="line">        d.fetch();                 // Dog fetches the ball</span><br><span class="line">//必须实现确保父类引用指向的是子类dog对象时才能发生向下转型。</span><br><span class="line">        // 如果强行将 Animal 引用转为 Cat，就会出错：</span><br><span class="line">        Animal a2 = new Animal();  </span><br><span class="line">        Dog d2 = (Dog) a2;          // ❌ 运行时出错：ClassCastException</span><br><span class="line">        d2.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多态解决了什么问题"><a href="#多态解决了什么问题" class="headerlink" title="多态解决了什么问题"></a>多态解决了什么问题</h3><p>多态可以提高代码的扩展性和复用性，是很多设计模式，设计原则，编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的if-else语句。</p>
<h3 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3><ul>
<li><p>单一职责原则（SRP）：一个类应该只有一个引起它变化的原因。每个类只负责一件事情。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UserService &#123;</span><br><span class="line">    public void registerUser() &#123; /* 注册逻辑 */ &#125;</span><br><span class="line">    public void loginUser() &#123; /* 登录逻辑 */ &#125;</span><br><span class="line">    // ❌ 不应该放这</span><br><span class="line">    public void logToFile() &#123; /* 日志逻辑 */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个类既然只负责用户，就应该把日志的工作单独设置一个类</p>
</li>
<li><p>开闭原则（OCP）：对扩展开放，对修改关闭。当需求变化时，通过扩展代码而不是修改原有代码。</p>
</li>
<li><p>里氏替换原则（LSP）：子类对象应该可以替换父类对象，并且程序逻辑不发生错误。子类要完整继承父类的行为，不破坏父类原有功能。</p>
<p>  那方法重写不就是违反里氏替换原则了吗？</p>
<p>  里氏替换原则（LSP）并不是禁止重写有实现的方法，而是要求子类重写后的行为要保持“语义一致”或者“可替代性”，也就是说：</p>
<p>  ✅ 子类可以重写任何父类方法（无论有没有默认实现），<br>  ❗ 但重写后不能破坏父类原本定义的语义或预期行为。</p>
<p>  父类就像是“合同”，里面写着“我承诺我能飞”；子类如果签了这个合同（继承了），就不能违约（说自己不能飞）；如果你压根不会飞，那你就别继承“飞行合同”——比如别继承 Bird，而去实现一个 WalkableAnimal。</p>
</li>
<li><p>依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖其抽象。面向接口编程，不依赖具体实现。</p>
</li>
<li><p>接口隔离原则（ISP）：不应该强迫类实现它用不到的接口。接口要精细化，避免“大而全”。</p>
</li>
<li><p>迪米特法则（LoD）（最少知道原则）：一个类应该对其他类尽可能少地了解。降低耦合，不该知道的不要知道。</p>
</li>
</ul>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ul>
<li>方法重载：同一个类中有多个同名方法，他们具有不同的参数列表（参数类型，顺序，数量不同）。虽然方法名字相同，但是根据传入的参数不同，编译器会在编译时确定正确的方法。</li>
<li>方法重写：指的是子类能够提供对于父类中同名方法的具体实现。子类可以重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致。在运行时JVM会根据对象的实际类型决定调用哪个版本的方法。</li>
</ul>
<h3 id="抽象类和普通类的区别"><a href="#抽象类和普通类的区别" class="headerlink" title="抽象类和普通类的区别"></a>抽象类和普通类的区别</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2025/04/05/%E8%BE%B0%E6%9B%A6%E5%8C%BB%E7%96%97%E5%B9%B3%E5%8F%B0/" rel="next" title="辰曦医疗平台">
      辰曦医疗平台 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">java的特点是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8A%A3%E5%8A%BF"><span class="nav-number">1.1.2.</span> <span class="nav-text">java的优势劣势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">java为什么是跨平台的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E3%80%81JDK%E3%80%81JRE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.4.</span> <span class="nav-text">JVM、JDK、JRE的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.</span> <span class="nav-text">编译型语言和解释型语言的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88java%E8%A7%A3%E9%87%8A%E5%92%8C%E7%BC%96%E8%AF%91%E9%83%BD%E6%9C%89"><span class="nav-number">1.1.6.</span> <span class="nav-text">为什么java解释和编译都有</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">八种基本的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.2.2.</span> <span class="nav-text">数据类型转换方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC%E5%90%8E%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">类型互转后会出现什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8bigDecimal%E4%B8%8D%E7%94%A8double"><span class="nav-number">1.2.4.</span> <span class="nav-text">为什么要使用bigDecimal不用double</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">1.2.5.</span> <span class="nav-text">装箱和拆箱是什么意思</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">1.2.6.</span> <span class="nav-text">java中为什么要有包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.7.</span> <span class="nav-text">Integer和int的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E5%8A%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BF%9D%E5%AD%98int"><span class="nav-number">1.2.8.</span> <span class="nav-text">Integer有这么多优势为什么还要保存int</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer%E7%9A%84%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="nav-number">1.2.9.</span> <span class="nav-text">Integer的缓存池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">怎么理解面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E9%82%A3%E4%BA%9B%E6%96%B9%E5%90%91"><span class="nav-number">1.3.2.</span> <span class="nav-text">多态体现在那些方向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.3.</span> <span class="nav-text">多态解决了什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.3.4.</span> <span class="nav-text">面向对象的设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.5.</span> <span class="nav-text">重载和重写的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%99%AE%E9%80%9A%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.6.</span> <span class="nav-text">抽象类和普通类的区别</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="April"
      src="/images/rose.jpg">
  <p class="site-author-name" itemprop="name">April</p>
  <div class="site-description" itemprop="description">Do not go gentle into that good night</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zhuoying-04" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zhuoying-04" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/G1_0603" title="Weixin → G1_0603"><i class="fa fa-envelope fa-fw"></i>Weixin</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">April</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">8k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
